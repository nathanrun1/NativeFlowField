#pragma kernel GenerateFlowField

#include "Adjacency.hlsl"

uint Width;
uint Height;
int DiagonalMovement;
int UseTravelCosts;
StructuredBuffer<float> TravelCosts;
StructuredBuffer<float> InputCosts;
RWStructuredBuffer<int> OutputFlowField;

int getFlow(uint x, uint y)
{
    int index = flatten(x, y, Width);
    float minCost = InputCosts[index];
    int bestNeighborIndex = index;

    if (minCost >= FLT_MAX) // Obstacle
    {
        return bestNeighborIndex;
    }

    [unroll]
    for (uint i = 0; i < numberOfDirections[DiagonalMovement]; ++i)
    {
        int nx = x + offsets[i].x;
        int ny = y + offsets[i].y;

        if (nx >= 0 && (uint)nx < Width && ny >= 0 && (uint)ny < Height)
        {
            bool isDiagonal = i >= 4;
            if (isDiagonal)
            {
                // Both orthogonal must be free
                if (InputCosts[flatten(x + offsets[i].x, y, Width)] >= FLT_MAX-1) continue;
                if (InputCosts[flatten(x, y + offsets[i].y, Width)] >= FLT_MAX-1) continue;
            }
            uint neighborIndex = flatten(nx, ny, Width);
            float neighborCost = InputCosts[neighborIndex];
            if (UseTravelCosts) neighborCost += TravelCosts[neighborIndex]; // Add travel cost

            if (neighborCost < FLT_MAX && neighborCost > FLT_MIN)
            {
                float stepCost = costs[i];
                if (minCost <= FLT_MIN || neighborCost + stepCost <= minCost) // Lowest cost so far
                {
                    minCost = neighborCost + stepCost;
                    bestNeighborIndex = neighborIndex;
                }
            }
        }
    }

    return bestNeighborIndex;
}

[numthreads(8, 8, 1)]
void GenerateFlowField(uint3 id : SV_DispatchThreadID)
{
    uint x = id.x;
    uint y = id.y;

    if (x >= Width || y >= Height)
    {
        return;
    }

    OutputFlowField[flatten(x, y, Width)] = getFlow(x, y);
}